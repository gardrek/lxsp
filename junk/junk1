    pub fn eval(&self, val: &LispValue) -> Result<LispValue, EvalError> {
        use LispValue::*;
        
        Ok(match val {
            Bool(_) | Integer(_) | Func(_) | UnsafeFunc(_) | Lambda(_) => val.fallible_clone()?,
            Symbol(s) => self
                .get(s)
                .ok_or(EvalError::String(format!(
                    "[internal eval] use of undeclared variable {}",
                    &s
                )))?
                .fallible_clone()?,
            List(list) => {
                if val.is_nil() {
                    val.fallible_clone()?
                } else {
                    let f = self.eval(&list[0])?;
                    //self.apply(&f, &list[1..])?
                    match f {
                        Func(_) | Lambda(_) => self.apply(&f, &list[1..])?,
                        UnsafeFunc(_) => {
                            return Err(EvalError::String(format!(
                                "unsafe functions must be called with the unsafe keyword [[ {} ]]",
                                &f
                            )))
                        }
                        Bool(_) | Integer(_) | Symbol(_) | List(_) => {
                            return Err(EvalError::String(format!(
                                "[internal fn: reduce] value cannot be called: {}",
                                &f
                            )))
                        }
                    }
                }
            }
        })
    }
